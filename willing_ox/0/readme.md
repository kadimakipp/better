## introduction

摘自趣学算法
> 算法作为一门学问，有两条几乎平行的线索。一个是数据结构(数据对象):数、矩阵、集合、串、排列、图、表达式、分布等，另一个是算法策略:贪心、分治、动态规划、线性规划、搜索等。
> 两条线索是相互独立的：同一个数据对象上有不同的问题(如单源最短路径合多源最短路径)，就可以用到不同的算法策略(例如贪婪合动态规划):而完全不同的数据对象上的问题(如排序和整数乘法)，也许就会用到相同的算法策略(如分治)。


### 算法时间复杂度分析和算法空间复杂度分析。

#### 算法时间复杂度衡量标准是**程序执行次数**。

时间复杂度O(n)的计算方法有几条原则。
1. 如果运行时间是常数量级，用常数1表示；
2. 只保留函数中的最高次项。
3. 如果最高阶项存在，则省去最高阶项前面的系数。
example O(logn)
```
for (int i=0;i<n;i*=2) -->T(O) = O(5logn) =O(logn)
```
没有常数量级且最高次项是logn，另按第3条原则，省去前面系数5.所以它的算法复杂度是O(logn)

#### 算法空间复杂度**只计算辅助空间**。

算法占用的存储空间包括:
1. 输入/输出数据。
2. 算法本身。
3. 额外的辅助空间。
空间复杂度只需要计算第3条即可。

#### 递归的时间复杂度和空间复杂度
递归包括递推和回归，递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。
    递归有两个重要的条件：
        1. 递推和回归
        2. 递推的结束条件，如果没有结束条件，编译器一般会报错。
时间复杂度可以除了其他计算，仅仅函数的调用就有2n次，然后在加上其他运算次数。
递归的分析可以做图辅助推理过程，来得到时间和空间复杂度。

递归在计算机内部的计算机制是使用栈(后进先出)的数据结构。将子问题从低到上入栈，然后达到结束条件后，在从上到低出栈。主要是把函数地址和函数私有参数放入栈中(不确定的说法>_>).在出栈的时候利用函数的私有参数计算得到结果。
所以空间复杂度必有栈这个数据结构的存储空间，然后在加上额外变量的存储空间。