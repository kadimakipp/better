## 线性表
线性表是由n(n>=0)个相同类型的数据元素组成的有限序列，它是最基本的、最常用的一种线性结构。顾名思义，线性表就像是一条线，不会分叉。线性表有唯一的开始和结束，除了第一个元素外，每个元素都有唯一的直接前驱，除了最后一个元素外，每个元素都有唯一的直接后继。

## 顺序表
顺序表是顺序存储方式，即逻辑上相邻的数据在计算机内的存储位置也是相邻的。顺序存储方式，元素存储是连续的，中间不允许有空，可以快速定位第几个元素，所以插入、删除时需要移动大量元素。

## 链表
链表是线性表的链试存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻。
- 单向链表
- 双向链表
- 循环链表


链表的基础操作有初始化，增，删，改，查。
其中增分为头插法和尾插法。
note:
1.单向链表的循环访问，我将其分为两类。
第一类链表的第一个节点开始查找，需要找到当前节点。
遍历，头插，查找，修改。
```
node *n = L->next;
while(n)
{
    n = n->next;
}
```
第二类从链表的第一个节点前的节点(空节点)开始，需要找到当前节点的前一个节点

```
node *n = L->next;
while(n->next)
{
    if(n->next->data==data) break;//删除操作
    n = n->next;
}
```

2.循环链表
```
//循环链表
typedef struct node{
int data
Node *prior;
Node *next;
}Node, *Cycl_Node;
//头结点初始化
CyclNode *C(data,null,null);
C->prior=C->next = C;
//尾插法
CyclNode n = C;
while(n->next!=n)
{
      n=n->next;
}
p->next=n->next;
n->next->prior=p;
n->next = p;
p->prior = n;
//删除
while(n->next!=n)
{
      if(n->next->data==data)
          break;
      n->next;
}
d = n->next;
d->next->prior = n;
n->next = d->next;
detele d;

while(n->next!=n)

```

## 链表的应用
1. 将两个有序(非递减)单链表La和Lb合并为一个新的有序(非递减)单链表。
   note: 链表合并并不需要在创建空间，只需要穿针引线，把两个单链表中的节点，按递减顺序串联起来即可。**单链表的头指针不可以移动**

2. 带有头结点的单链表L，设计一个尽可能高效的算法求解L中的中间结点。
   note:快慢指针，一个快指针，一个慢指针，快指针走两步慢指针走一步，当快指针指向结尾的时候，慢指针刚好指向中间结点。

3. 在单链表中查找倒数第k个结点。
   note:快慢指针，快指针先走k步。

4. 用单链表保存m个整数，结点的结构为(data， next)，且$|data|<=n$(n为正整数)现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。
   note: 建立长度为n+1的表，初始化为0，遍历结点，查表，表为0，结点对应位置写1，表值为1，对应节点删除。